<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title> Shipment </title>

  <link rel="stylesheet" as="style" crossorigin
    href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/static/pretendard.css" />
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <style>
    :root{
      --bg1:#f7f4ff; --bg2:#eef6ff;
      --card:rgba(255,255,255,.9);
      --stroke:rgba(170,150,230,.22);
      --text:#2f2a3a;
      --shadow:0 18px 50px rgba(30,18,60,.10);
      --shadow2:0 10px 26px rgba(30,18,60,.08);

      --low-bg: rgba(255, 70, 70, .10);
      --low-border: rgba(255, 70, 70, .35);
      --low-text: rgba(160, 20, 20, .95);

      --out-bg: rgba(255, 35, 35, .16);
      --out-border: rgba(255, 35, 35, .55);
      --out-text: rgba(135, 0, 0, .98);

      --na-bg: rgba(120,120,140,.10);
      --na-border: rgba(120,120,140,.35);
      --na-text: rgba(80,80,95,.95);

      --ok-bg: rgba(184,167,255,.14);
      --ok-border: rgba(170,150,230,.35);
      --ok-text: rgba(47,42,58,.92);

      --pink:#ff8fbc;
    }
    *{box-sizing:border-box;font-family:"Pretendard",system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;}
    body{
      margin:0; min-height:100vh; color:var(--text);
      background:
        radial-gradient(900px 520px at 20% 18%, rgba(255,143,188,.25), transparent 60%),
        radial-gradient(900px 520px at 82% 24%, rgba(184,167,255,.20), transparent 58%),
        linear-gradient(180deg, var(--bg1), var(--bg2));
    }

    .field-label{ font-size:12px; opacity:.75; white-space:nowrap; min-width:52px; flex:0 0 auto; }
    .container{max-width:1400px;margin:0 auto;padding:28px 16px 46px;}
    .card{ background:var(--card); border:1px solid var(--stroke); border-radius:20px; box-shadow:var(--shadow); overflow:hidden; }
    .card-inner{padding:18px;}
    .title{ display:flex; align-items:center; justify-content:space-between; gap:10px; font-size:18px; font-weight:900; }
    .meta{ margin-top:8px; display:flex; flex-wrap:wrap; gap:8px; color:rgba(110,106,130,.85); font-size:12px; align-items:center; line-height:1.2; }
    .pill{
      font-size:11px; padding:5px 10px; border-radius:999px;
      background: linear-gradient(90deg, rgba(255,143,188,.20), rgba(184,167,255,.16));
      border:1px solid rgba(170,150,230,.25);
      box-shadow: 0 1px 0 rgba(255,255,255,.55) inset;
      text-decoration:none; color:rgba(47,42,58,.82);
      display:inline-flex; align-items:center; gap:6px;
    }
    .pill:hover{ border-color: rgba(255,143,188,.55); box-shadow: 0 0 0 3px rgba(255,143,188,.14), 0 1px 0 rgba(255,255,255,.55) inset; }

    .row{display:flex; gap:10px; align-items:center; margin-top:14px; flex-wrap:wrap;}
    .input{
      flex:1; min-width:240px; display:flex; align-items:center; gap:8px;
      padding:10px 12px; border-radius:14px;
      background:rgba(243,241,250,.85);
      border:1px solid rgba(170,150,230,.20);
      box-shadow: var(--shadow2);
    }
    .input input{ width:100%; border:0; outline:0; background:transparent; font-size:13px; }
    .btn{
      border:0; cursor:pointer; padding:10px 14px; border-radius:14px;
      background:rgba(255,255,255,.82); border:1px solid rgba(170,150,230,.25);
      box-shadow: var(--shadow2); font-weight:900;
    }
    .btn:hover{border-color: rgba(255,143,188,.55); box-shadow: 0 0 0 3px rgba(255,143,188,.12), var(--shadow2);}
    .btn:disabled{cursor:not-allowed; opacity:.55; filter:saturate(.8); box-shadow:none;}

    .badge{
      display:inline-flex; align-items:center; gap:6px; padding:4px 10px;
      border-radius:999px; border:1px solid rgba(170,150,230,.25);
      background: rgba(255,255,255,.70);
      font-weight:900; font-size:11px; white-space:nowrap;
    }
    .badge.ok{ background: var(--ok-bg); border-color: var(--ok-border); color: var(--ok-text); }
    .badge.low{ background: var(--low-bg); border-color: var(--low-border); color: var(--low-text); }
    .badge.out{ background: var(--out-bg); border-color: var(--out-border); color: var(--out-text); }
    .badge.na{ background: var(--na-bg); border-color: var(--na-border); color: var(--na-text); }

    .warnline{font-size:11px; font-weight:900;}
    .warnline.low{color: var(--low-text);}
    .warnline.out{color: var(--out-text);}
    .warnline.na{color: var(--na-text);}

    .table-wrap{
      margin-top:14px; border-radius:16px; border:1px solid rgba(170,150,230,.18);
      overflow:auto; background: rgba(255,255,255,.68);
      box-shadow: 0 1px 0 rgba(255,255,255,.70) inset;
      max-height: 72vh; scrollbar-gutter: stable;
    }
    table{width:100%; border-collapse:separate; border-spacing:0; font-size:12px;}
    thead th{
      position:sticky; top:0; z-index:2; text-align:left; padding:10px 12px;
      background: rgba(255,255,255,.86);
      border-bottom: 1px solid rgba(170,150,230,.18);
      font-weight:900; white-space:nowrap;
    }
    tbody td{
      padding:10px 12px; border-bottom:1px solid rgba(170,150,230,.12);
      vertical-align:top; white-space: nowrap;
    }
    tbody tr:nth-child(even){background: rgba(243,241,250,.55);}
    tbody tr:hover{background: linear-gradient(90deg, rgba(255,143,188,.18), rgba(184,167,255,.14));}
    .no-data{padding:20px 14px; text-align:center; color: rgba(110,106,130,.75); font-size:12px;}
    tr.low { background: var(--low-bg) !important; }
    tr.out { background: var(--out-bg) !important; }
    tr.na { background: rgba(120,120,140,.07) !important; }
    .copy{cursor:pointer;}
    .chkcell{ text-align:center; }

    .panel{
      margin-top: 12px; padding: 12px; border-radius: 16px;
      border: 1px dashed rgba(170,150,230,.35);
      background: rgba(255,255,255,.65);
      display:none; gap:10px; align-items:center; flex-wrap:wrap;
    }
    .panel.show{display:flex;}
    .panel .label{ font-size:12px; font-weight:900; color: rgba(47,42,58,.88); }

    .miniinput{
      display:flex; align-items:center; gap:8px; padding:8px 10px; border-radius:12px;
      background: rgba(243,241,250,.85);
      border:1px solid rgba(170,150,230,.20);
      box-shadow: var(--shadow2);
    }
    .miniinput input{
      border:0; outline:0; background:transparent; width:220px; font-size:12.5px;
    }
    .minihelp{ font-size:11px; color: rgba(110,106,130,.85); }
    .miniinput select{
      border:0; outline:0; background:transparent; width: 280px; font-size:12.5px;
    }

    #toast{
      position:fixed; right:18px; bottom:18px; z-index:9999;
      padding:10px 12px; border-radius:14px;
      background: rgba(255,255,255,.90);
      border:1px solid rgba(255,143,188,.35);
      box-shadow: var(--shadow);
      opacity:0; transform: translateY(10px);
      transition:.18s ease; pointer-events:none; font-weight:900;
    }
    #toast.show{opacity:1; transform:translateY(0);}

    .input:focus-within, .miniinput:focus-within{
      border-color: rgba(255,143,188,.55);
      box-shadow: 0 0 0 3px rgba(255,143,188,.12), var(--shadow2);
    }
    #status{ font-weight:900; }
    #stat2{ opacity:.75; }
    #copyGateMsg{
      padding:4px 8px; border-radius:999px;
      background: rgba(255,255,255,.55);
      border:1px solid rgba(170,150,230,.18);
    }
    tr.is-selected{
      outline: 2px solid rgba(255,143,188,.45);
      outline-offset: -2px;
      background: linear-gradient(90deg, rgba(255,143,188,.22), rgba(184,167,255,.18)) !important;
    }
    #changePanel{ position: sticky; bottom: 10px; z-index: 50; backdrop-filter: blur(10px); }
    #changePanel.show{ box-shadow: 0 18px 50px rgba(30,18,60,.12); }

    .toolbar{
      margin-top: 10px; padding: 10px 12px; border-radius: 16px;
      border: 1px solid rgba(170,150,230,.18);
      background: rgba(255,255,255,.65);
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
    }
    .toolbar .hint{ font-size:11px; opacity:.75; }
    .kbd{
      font-size:11px; border:1px solid rgba(170,150,230,.25);
      padding:2px 6px; border-radius:8px; background: rgba(255,255,255,.70);
      font-weight:900;
    }

    .spinner{
      width:14px; height:14px; border-radius:50%;
      border:2px solid rgba(170,150,230,.25);
      border-top-color: rgba(255,143,188,.85);
      display:inline-block; animation: spin .8s linear infinite; vertical-align:-2px;
    }
    @keyframes spin{ to{ transform: rotate(360deg); } }

    #hoverTip{
      position: fixed; z-index: 10000;
      max-width: min(560px, 92vw); max-height: min(280px, 40vh);
      overflow: auto;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(170,150,230,.35);
      background: rgba(255,255,255,.97);
      box-shadow: 0 18px 50px rgba(30,18,60,.16);
      font-size: 12px; font-weight: 700; color: rgba(47,42,58,.95);
      line-height: 1.35;
      opacity: 0; transform: translateY(-4px);
      pointer-events: none; transition: .10s ease;
      display: none; white-space: pre-wrap; word-break: break-word;
    }
    #hoverTip.show{ display: block; opacity: 1; transform: translateY(0); }

    /* ìƒë‹¨ ìš”ì•½ ìˆ¨ê¹€ */
    #stat2, #stockSummary, #copyGateMsg { display:none !important; }

    .dupBanner{
      margin-top: 12px;
      border-radius: 18px;
      border: 1px solid rgba(255,35,35,.45);
      background: linear-gradient(90deg, rgba(255,35,35,.18), rgba(255,143,188,.10));
      box-shadow: 0 18px 50px rgba(255,35,35,.12);
      padding: 12px 14px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
    }
    .dupBannerLeft{ display:flex; align-items:center; gap:12px; }
    .dupIcon{
      width:38px; height:38px; border-radius:14px;
      display:flex; align-items:center; justify-content:center;
      background: rgba(255,35,35,.18);
      border:1px solid rgba(255,35,35,.35);
      font-size:18px;
    }
    .dupTitle{
      font-size:15px;
      font-weight: 900;
      color: rgba(135,0,0,.98);
      line-height: 1.1;
    }
    .dupSub{
      margin-top: 2px;
      font-size: 12px;
      font-weight: 800;
      color: rgba(135,0,0,.80);
    }
    .dupBannerRight{ display:flex; gap:8px; align-items:center; }
    .dupBtn{
      background: rgba(255,255,255,.85);
      border:1px solid rgba(255,35,35,.35);
    }
    .dupBtn:hover{
      border-color: rgba(255,35,35,.65);
      box-shadow: 0 0 0 3px rgba(255,35,35,.12), var(--shadow2);
    }
    .dupBannerDetail{
      width:100%;
      margin-top: 10px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .dupCard{
      border-radius:14px;
      background: rgba(255,255,255,.78);
      border: 1px solid rgba(255,35,35,.22);
      padding: 10px 12px;
      display:flex;
      flex-direction:column;
      gap:4px;
    }
    .dupLine1{
      font-weight: 900;
      font-size: 12.5px;
      color: rgba(47,42,58,.94);
    }
    .dupLine2{
      font-weight: 800;
      font-size: 11.5px;
      color: rgba(110,106,130,.88);
      display:flex;
      gap:10px;
      flex-wrap:wrap;
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="card">
      <div class="card-inner">
        <div class="title">
          <div> Shipment </div>
          <div style="display:flex; gap:8px; flex-wrap:wrap;">
            <a class="pill" id="orderLink" href="#" target="_blank" rel="noopener noreferrer">ë°œì£¼ì„œ</a>
            <a class="pill" id="stockLink" href="#" target="_blank" rel="noopener noreferrer">ì¬ê³ </a>
            <a class="pill" id="existLink" href="#" target="_blank" rel="noopener noreferrer"> ì¶œê³  </a>
          </div>
        </div>

        <div class="meta">
          <span id="status">ë¡œë”© ì¤‘â€¦</span>
          <span id="stat2"></span>
          <span id="stockSummary"></span>
          <span id="copyGateMsg"></span>
        </div>

        <div class="dupBanner" id="dupBanner" style="display:none;">
          <div class="dupBannerLeft">
            <div class="dupIcon">ğŸ”´</div>
            <div>
              <div class="dupTitle">ì´ì¤‘ ì¶œê³  ì˜ì‹¬</div>
              <div class="dupSub" id="dupBannerSub">-</div>
            </div>
          </div>
          <div class="dupBannerRight">
            <button class="btn dupBtn" id="dupBannerToggle" type="button">ìì„¸íˆ</button>
          </div>
          <div class="dupBannerDetail" id="dupBannerDetail" style="display:none;"></div>
        </div>

        <div class="panel" id="existPanel" style="display:none;">
          <span class="label">ê¸°ì¡´ ë“±ë¡ ë°ì´í„°</span>
          <button class="btn" id="btnExistToggle" type="button">í¼ì¹˜ê¸°</button>

          <div id="existBody" style="display:none; width:100%;">
            <div class="toolbar" id="tableToolbar" style="display:none;">
              <span class="hint">
                í–‰ í´ë¦­í•˜ë©´ ë³µì‚¬ Â· ì—¬ëŸ¬ ê±´ì´ë©´ ì²´í¬ í›„ <span class="kbd">ë³€ê²½</span> ì ìš© Â·
                <span class="kbd">Ctrl</span>+<span class="kbd">C</span> ë¡œ ë³µì‚¬
              </span>
              <span id="selCount" class="badge ok" style="display:none;">ì„ íƒ 0ê±´</span>
              <button class="btn" id="btnSelectAll" type="button" style="display:none;">ì „ì²´ ì„ íƒ</button>
              <button class="btn" id="btnSelectNone" type="button" style="display:none;">ì„ íƒ í•´ì œ</button>
            </div>

            <div class="table-wrap" style="max-height:240px; width:100%; margin-top:8px;">
              <table style="width:100%; border-collapse:separate; border-spacing:0; font-size:12px;">
                <thead>
                  <tr>
                    <th>ì‚¬ë°©ë„·ì£¼ë¬¸ë²ˆí˜¸</th>
                    <th>ì‡¼í•‘ëª° ì£¼ë¬¸ë²ˆí˜¸</th>
                    <th>ëª©ì </th>
                    <th>ì „ì‚° ì²˜ë¦¬ ë°©ë²•</th>
                    <th>ê¸°ë¡ì¼(ìˆìœ¼ë©´)</th>
                  </tr>
                </thead>
                <tbody id="existTbody"></tbody>
              </table>
            </div>
            <div class="minihelp" style="margin-top:8px;">
              â€» ì´ ì£¼ë¬¸ë²ˆí˜¸ë¡œ ì´ë¯¸ ì…ë ¥ëœ ëª©ì /ì „ì‚° ì²˜ë¦¬ ë°©ë²•ì´ ìˆìœ¼ë©´ ì—¬ê¸°ì„œ í™•ì¸ë©ë‹ˆë‹¤.
            </div>
          </div>
        </div>

        <div class="row">
          <div class="input">
            <span class="field-label">ê²€ìƒ‰</span>
            <input id="orderInput" type="text" placeholder="ì£¼ë¬¸ë²ˆí˜¸/ì†¡ì¥/ì—°ë½ì²˜/ìˆ˜ë ¹ì¸ ì…ë ¥ (Enter)" />
          </div>
        </div>

        <div class="panel" id="manualPanel">
          <span class="label">ë°œì£¼ì„œì— ì—†ìŒ â†’ ìˆ˜ë™ ì…ë ¥</span>
          <div class="miniinput">
            <span style="font-size:11px;opacity:.75;">ìƒí’ˆì»¬ëŸ¬ì½”ë“œ</span>
            <input id="manualColor" type="text" placeholder="ì˜ˆ: ABC123 (í•„ìˆ˜)" />
          </div>
          <div class="miniinput" style="width:180px;">
            <span style="font-size:11px;opacity:.75;">ìˆ˜ëŸ‰</span>
            <input id="manualQty" type="text" placeholder="ì˜ˆ: 1" />
          </div>
          <button class="btn" id="btnManualApply">ì ìš©</button>
          <span class="minihelp">ì¬ê³  10 ë¯¸ë§Œ/0/ë¯¸ë“±ë¡ì´ë©´ ë³µì‚¬ ì°¨ë‹¨ Â· Ctrl+Cë¡œ ë³µì‚¬</span>
        </div>

        <div class="panel" id="changePanel">
          <span class="label">ë³€ê²½</span>

          <div class="miniinput">
            <span style="font-size:11px;opacity:.75;">ìƒ‰ìƒ ì„ íƒ</span>
            <select id="changeColorSelect" title="ìƒ‰ìƒëª…(Iì—´)ë¡œ ì„ íƒí•˜ë©´ ì»¬ëŸ¬ì½”ë“œê°€ ìë™ ì…ë ¥ë©ë‹ˆë‹¤. (LOW/OUT/N/AëŠ” ì„ íƒ ë¶ˆê°€)">
              <option value="">ì„ íƒí•˜ì„¸ìš”</option>
            </select>
          </div>

          <div class="miniinput">
            <span style="font-size:11px;opacity:.75;">ì»¬ëŸ¬ì½”ë“œ</span>
            <input id="changeColor" type="text" placeholder="ì˜ˆ: ABC123 (í•„ìˆ˜)" />
          </div>

          <div class="miniinput" style="width:180px;">
            <span style="font-size:11px;opacity:.75;">ìˆ˜ëŸ‰</span>
            <input id="changeQty" type="text" placeholder="ì˜ˆ: 1" />
          </div>

          <button class="btn" id="btnChangeApply">ì ìš©</button>
          <button class="btn" id="btnChangeReset">ì·¨ì†Œ</button>
        </div>

        <div class="table-wrap" id="tableWrap">
          <div class="no-data">ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.</div>
        </div>
      </div>
    </div>
  </div>

  <div id="toast"> copy </div>
  <div id="hoverTip"></div>

  <script>
    /* ===================== ê¸°ì¤€ ===================== */
    const LOW_STOCK_THRESHOLD = 10;

    /* ===================== ì‹œíŠ¸ ===================== */
    const ORDER_SHEET_URL_VIEW = "https://docs.google.com/spreadsheets/d/1_Bxfag-90U6u-6JbhxNqeoD9vRns-CpPeXPIJYO1Z5o/edit?gid=518656308#gid=518656308";
    const ORDER_CSV_BASE = "https://docs.google.com/spreadsheets/d/1_Bxfag-90U6u-6JbhxNqeoD9vRns-CpPeXPIJYO1Z5o/export?format=csv&gid=518656308";

    const STOCK_SHEET_URL_VIEW = "https://docs.google.com/spreadsheets/d/1_L12NKkBVU4c5xDPrYLUQRnSUG2NoAwYGWIfPDVO3bM/edit?gid=366983013#gid=366983013";
    const STOCK_CSV_BASE = "https://docs.google.com/spreadsheets/d/1_L12NKkBVU4c5xDPrYLUQRnSUG2NoAwYGWIfPDVO3bM/export?format=csv&gid=366983013";

    const EXIST_SHEET_URL_VIEW_2025 = "https://docs.google.com/spreadsheets/d/1LPy69E2yPTaSwxFAYrX6qV0BZx1tW0YdonLRNqeo5Vc/edit?gid=0#gid=0";
    const EXIST_CSV_BASE_2025 = "https://docs.google.com/spreadsheets/d/1LPy69E2yPTaSwxFAYrX6qV0BZx1tW0YdonLRNqeo5Vc/export?format=csv&gid=0";

    const EXIST_SHEET_URL_VIEW_2026 = "https://docs.google.com/spreadsheets/d/1LPy69E2yPTaSwxFAYrX6qV0BZx1tW0YdonLRNqeo5Vc/edit?gid=883501265#gid=883501265";
    const EXIST_CSV_BASE_2026 = "https://docs.google.com/spreadsheets/d/1LPy69E2yPTaSwxFAYrX6qV0BZx1tW0YdonLRNqeo5Vc/export?format=csv&gid=883501265";

    document.getElementById("orderLink").href = ORDER_SHEET_URL_VIEW;
    document.getElementById("stockLink").href = STOCK_SHEET_URL_VIEW;
    document.getElementById("existLink").href = EXIST_SHEET_URL_VIEW_2026;

    /* ===================== ESC: ì „ì²´ ì´ˆê¸°í™” ===================== */
    document.addEventListener("keydown", (e)=>{
      if(e.key !== "Escape") return;
      e.preventDefault();
      resetAll_();
    });

    /* ===================== ê°•ì œ í¬í•¨ B/C/D ===================== */
    const EXTRA_COLS = [
      { key: "__B", label: "ì‚¬ë°©ë„·ì£¼ë¬¸ë²ˆí˜¸", idx: 1 },
      { key: "__C", label: "ì‡¼í•‘ëª° ì£¼ë¬¸ë²ˆí˜¸(í•„ìˆ˜)", idx: 2 },
      { key: "__D", label: "ì‡¼í•‘ëª°", idx: 3 },
    ];

    /* ===================== ìš”ì²­ ì¶œë ¥ ì»¬ëŸ¼ ===================== */
    const OUTPUT_HEADERS = [
      "ìš”ì²­ì¼", "ìˆ˜ë ¹ì¸","ë°°ì†¡ìˆ˜ë‹¨","ìš´ì†¡ì¥ ë²ˆí˜¸","ë°›ëŠ”ë¶„ì—°ë½ì²˜","ë°›ëŠ”ë¶„ ê¸°íƒ€ì—°ë½ì²˜","ì£¼ì†Œ","ë°°ì†¡ë©”ì„¸ì§€",
      "ìƒí’ˆëª…","ìˆ˜ëŸ‰","ê²°ì œê¸ˆì•¡","íí…(í•œê¸€ìƒí’ˆëª…)","ë°”ì½”ë“œ","íí…ë°”ì½”ë“œ",
      "ìƒí’ˆì½”ë“œ","ì‡¼í•‘ëª°(ì°¸ê³ ìš©)","ìƒí’ˆì»¬ëŸ¬ì½”ë“œ","ìƒí’ˆëª…(ìˆ˜ì§‘)","ì˜µì…˜(ìˆ˜ì§‘)","ì£¼ë¬¸ìëª…",
      "ë¹„ê³ "
    ];

    /* ===================== í™”ë©´ ìˆ¨ê¹€/ë³µì‚¬ ì œì™¸ ê·œì¹™ ===================== */
    // ìš”êµ¬ì‚¬í•­: ë…¸ì¶œ ì¶”ê°€(ìš´ì†¡ì¥/ì—°ë½ì²˜), ìˆ¨ê¹€(ë°”ì½”ë“œ/ìƒí’ˆì½”ë“œ)
    const HIDE_IN_VIEW = new Set([
      "ë°°ì†¡ë©”ì„¸ì§€","íí…(í•œê¸€ìƒí’ˆëª…)","íí…ë°”ì½”ë“œ","ì‡¼í•‘ëª°(ì°¸ê³ ìš©)","ìƒí’ˆëª…(ìˆ˜ì§‘)","ë¹„ê³ ","ì£¼ë¬¸ìëª…",
      "ë°›ëŠ”ë¶„ ê¸°íƒ€ì—°ë½ì²˜","ì£¼ì†Œ","ë°°ì†¡ìˆ˜ë‹¨","ë°”ì½”ë“œ","ìƒí’ˆì½”ë“œ"
    ]);

    // ìš”êµ¬ì‚¬í•­: ìš´ì†¡ì¥ ë²ˆí˜¸ëŠ” "ë…¸ì¶œ"í•˜ë˜, ë³µì‚¬ì—ì„œëŠ” ì œì™¸
    const EXCLUDE_IN_COPY = new Set(["ìš´ì†¡ì¥ ë²ˆí˜¸"]);

    const TABLE_COLS_ALL = [
      { key: "ìš”ì²­ì¼", label: "ìš”ì²­ì¼" },
      ...EXTRA_COLS.map(c => ({ key:c.key, label:c.label })),
      { key: "ìˆ˜ë ¹ì¸", label: "ìˆ˜ë ¹ì¸" },
      ...OUTPUT_HEADERS
        .filter(h => !["ìš”ì²­ì¼","ìˆ˜ë ¹ì¸"].includes(h))
        .map(h => ({ key:h, label:h }))
    ];
    const TABLE_COLS_COPY = TABLE_COLS_ALL.filter(c => !EXCLUDE_IN_COPY.has(c.label));
    const TABLE_COLS_VIEW = TABLE_COLS_ALL.filter(c => !HIDE_IN_VIEW.has(c.label));

    const COL_WIDTH = {
      "ìš”ì²­ì¼":80, "ì‚¬ë°©ë„·ì£¼ë¬¸ë²ˆí˜¸": 100, "ì‡¼í•‘ëª° ì£¼ë¬¸ë²ˆí˜¸(í•„ìˆ˜)": 130,"ì‡¼í•‘ëª°":80,
      "ìƒí’ˆëª…": 200, "ìƒí’ˆì»¬ëŸ¬ì½”ë“œ": 100, "ê²°ì œê¸ˆì•¡": 80,
      "ì˜µì…˜(ìˆ˜ì§‘)": 100, "ìš´ì†¡ì¥ ë²ˆí˜¸": 120, "ë°›ëŠ”ë¶„ì—°ë½ì²˜": 130,
      "_default": 60
    };

    /* ===================== ìœ í‹¸ ===================== */
    const $ = (id)=>document.getElementById(id);

    function showToast(msg="ë³µì‚¬ë¨"){
      const el = $("toast");
      el.textContent = msg;
      el.classList.add("show");
      setTimeout(()=>el.classList.remove("show"), 850);
    }

    function withCacheBust(url){
      const sep = url.includes("?") ? "&" : "?";
      return `${url}${sep}_=${Date.now()}`;
    }

    function looksLikeBadCsv(text){
      const t = String(text || "").trim();
      if(!t) return true;
      const head = t.slice(0, 200).toLowerCase();
      if(head.includes("<!doctype") || head.includes("<html") || head.includes("servicelogin")) return true;
      if(t.length < 30) return true;
      return false;
    }

    async function fetchText(url, timeoutMs = 12000){
      const controller = new AbortController();
      const t = setTimeout(()=>controller.abort(), timeoutMs);
      try{
        const res = await fetch(url, { signal: controller.signal, cache: "no-store" });
        if(!res.ok) throw new Error("HTTP " + res.status);
        return await res.text();
      } finally {
        clearTimeout(t);
      }
    }

    async function fetchCsvSmart(baseUrl, timeoutMs=12000){
      const t1 = await fetchText(baseUrl, timeoutMs).catch(()=> "");
      if(!looksLikeBadCsv(t1)) return t1;
      const t2 = await fetchText(withCacheBust(baseUrl), timeoutMs).catch(()=> "");
      if(!looksLikeBadCsv(t2)) return t2;
      return t2 || t1;
    }

    function normalizeKey(v){
      return String(v ?? "")
        .replace(/[\u200B-\u200D\uFEFF]/g, "")
        .trim();
    }
    function normalizeOrderNo(v){ return normalizeKey(v); }

    function normLoose_(v){
      return String(v ?? "")
        .replace(/[\s\-]/g, "")
        .trim()
        .toLowerCase();
    }
    function normDigits_(v){
      return String(v ?? "")
        .replace(/[^0-9]/g, "");
    }

    function sciToIntString_(s){
      s = String(s ?? "").trim();
      if(!/[eE]/.test(s)) return s;
      const m = s.match(/^([+-]?\d+(?:\.\d+)?)[eE]([+-]?\d+)$/);
      if(!m) return s;

      let mant = m[1];
      const exp = parseInt(m[2], 10);
      const sign = mant.startsWith("-") ? "-" : "";
      mant = mant.replace(/^[+-]/, "");

      const parts = mant.split(".");
      const intPart = parts[0];
      const fracPart = parts[1] || "";
      const digits = (intPart + fracPart).replace(/^0+/, "") || "0";

      const shift = exp - fracPart.length;
      if(shift >= 0) return sign + digits + "0".repeat(shift);

      const cut = digits.length + shift;
      if(cut <= 0) return sign + "0";
      return sign + digits.slice(0, cut);
    }

    function normalizeForContains_(s){
      return normalizeKey(sciToIntString_(s));
    }

    function normColorCode(v){
      return normalizeKey(v).replace(/\s+/g,"").replace(/-/g,"").toUpperCase();
    }
    function normProductCode_(v){
      return normalizeKey(v).replace(/\s+/g,"").toUpperCase();
    }

    function toNumber(v){
      const n = String(v ?? "").replace(/[^0-9.-]/g,"");
      return Number(n) || 0;
    }

    function escapeHtml(str){
      return String(str ?? "")
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#039;");
    }

    /* ===================== ë¡œë”© UI ===================== */
    function setLoadingUI_(on, msg){
      const st = $("status");
      if(!st) return;
      if(on){
        st.innerHTML = `<span class="spinner"></span> ${escapeHtml(msg || "ë¡œë”© ì¤‘â€¦")}`;
      }else{
        st.textContent = msg || "ë¡œë”© ì™„ë£Œ";
      }
    }

    /* ===================== ì¬ê³  ë§µ ===================== */
    let stockMap = new Map();
    let stockInfoMap = new Map();

    function colorNameFromStock_(colorCodeRaw){
      const code = normColorCode(colorCodeRaw);
      const info = stockInfoMap.get(code);
      return (info?.colorName || "").trim();
    }

    function stockQtyLabel_(colorCodeRaw){
      const code = normColorCode(colorCodeRaw);
      if(!code) return "ë¯¸ë“±ë¡";
      if(!stockMap.has(code)) return "ë¯¸ë“±ë¡";
      return String(stockMap.get(code));
    }

    function stripStockTag_(s){
      return String(s ?? "").replace(/\s*\[ì¬ê³ :.*?\]\s*/g, " ").trim();
    }

    function attachStockToRequestDate_(reqDate, colorCode){
      const base = stripStockTag_(reqDate);
      const code = normColorCode(colorCode);
      let qtyLabel = "ë¯¸ë“±ë¡";
      if(code && stockMap.has(code)) qtyLabel = String(stockMap.get(code));
      const tag = `[ì¬ê³ :${qtyLabel}]`;
      return base ? `${base} ${tag}` : tag;
    }

    function nameFromStock_(colorCodeRaw){
      const code = normColorCode(colorCodeRaw);
      const info = stockInfoMap.get(code);
      if(!info) return "";
      const a = (info.name || "").trim();
      const b = (info.colorName || "").trim();
      if(a && b) return `${a} ${b}`;
      return a || b || "";
    }

    function stockStatusByColorCode(colorCodeRaw){
      const code = normColorCode(colorCodeRaw);
      if(!code) return { type:"na", label:"ì¬ê³  ë¯¸ë“±ë¡", qty:null };
      if(!stockMap.has(code)) return { type:"na", label:"ì¬ê³  ë¯¸ë“±ë¡", qty:null };
      const qty = stockMap.get(code);
      if(qty <= 0) return { type:"out", label:`ì¬ê³  0`, qty };
      if(qty < LOW_STOCK_THRESHOLD) return { type:"low", label:`ì¬ê³  ${qty} (${LOW_STOCK_THRESHOLD} ë¯¸ë§Œ)`, qty };
      return { type:"ok", label:`ì¬ê³  ${qty}`, qty };
    }

    /* ===================== ìƒ‰ìƒ ë“œë¡­ë‹¤ìš´ ===================== */
    let colorSelectWired = false;

    function getAllowedProductCodesForDropdown_(){
      if(!lastOutRows || lastOutRows.length === 0) return new Set();
      let idxs = [];
      if(lastOutRows.length > 1){
        idxs = getCheckedIndexes_();
      }
      if(!idxs.length) idxs = [0];
      const set = new Set();
      for(const idx of idxs){
        const pc = normProductCode_(lastOutRows[idx]?.["ìƒí’ˆì½”ë“œ"]);
        if(pc) set.add(pc);
      }
      return set;
    }

    function rebuildColorSelectOptions_(allowedProductCodes){
      const sel = $("changeColorSelect");
      if(!sel) return;
      const allowAll = !allowedProductCodes || allowedProductCodes.size === 0;
      sel.innerHTML = `<option value="">ì„ íƒí•˜ì„¸ìš”</option>`;
      const items = [];
      stockInfoMap.forEach((info, code)=>{
        const color = (info?.colorName || "").trim();
        const label = color || "(ìƒ‰ìƒëª… ì—†ìŒ)";
        let isAllowed = true;
        if(!allowAll){
          isAllowed = Array.from(allowedProductCodes).some(pc => String(code).startsWith(pc));
        }
        if(!isAllowed) return;
        const st = stockStatusByColorCode(code);
        items.push({ code, label, type: st.type });
      });

      items.sort((a,b)=>{
        const c = a.label.localeCompare(b.label, "ko");
        if(c !== 0) return c;
        return a.code.localeCompare(b.code);
      });

      const frag = document.createDocumentFragment();
      for(const it of items){
        const opt = document.createElement("option");
        opt.value = it.code;
        const tag = it.type === "ok" ? "" : it.type === "low" ? " (LOW)" : it.type === "out" ? " (OUT)" : " (N/A)";
        opt.textContent = `${it.label}${tag}`;
        if(it.type !== "ok") opt.disabled = true;
        frag.appendChild(opt);
      }
      sel.appendChild(frag);
    }

    function refreshColorDropdownByCurrentRows_(){
      const allowed = getAllowedProductCodesForDropdown_();
      rebuildColorSelectOptions_(allowed);
      const sel = $("changeColorSelect");
      const code = normColorCode($("changeColor")?.value || "");
      const st = stockStatusByColorCode(code);
      if(sel) sel.value = (st.type === "ok") ? code : "";
    }

    function wireColorSelect_(){
      if(colorSelectWired) return;
      const sel = $("changeColorSelect");
      const input = $("changeColor");
      if(!sel || !input) return;

      sel.addEventListener("change", ()=>{
        const code = sel.value;
        if(code){
          input.value = code;
          input.dispatchEvent(new Event("input", { bubbles:true }));
        }
      });

      input.addEventListener("input", ()=>{
        const code = normColorCode(input.value);
        const st = stockStatusByColorCode(code);
        sel.value = (st.type === "ok") ? code : "";
      });

      colorSelectWired = true;
    }

    /* ===================== ìˆ¨ê¹€ UI ===================== */
    function clearStockUI(){
      $("stockSummary").textContent = "";
      $("copyGateMsg").textContent = "";
      $("copyGateMsg").className = "";
    }
    function setPanel(which, on){
      const el = which === "manual" ? $("manualPanel") : $("changePanel");
      el.classList.toggle("show", !!on);
    }

    /* ===================== DUP ë°°ë„ˆ ===================== */
    let dupMatchesForTable_ = [];
    function hideDupBanner_(){
      const b = $("dupBanner");
      if(!b) return;
      b.style.display = "none";
      $("dupBannerSub").textContent = "-";
      $("dupBannerDetail").innerHTML = "";
      $("dupBannerDetail").style.display = "none";
      $("dupBannerToggle").textContent = "ìì„¸íˆ";
    }
    function renderDupBanner_(){
      const b = $("dupBanner");
      if(!b) return;
      if(!dupMatchesForTable_ || dupMatchesForTable_.length === 0){
        hideDupBanner_();
        return;
      }
      const count = dupMatchesForTable_.length;
      $("dupBannerSub").textContent = `ì¶œê³  ì‹œíŠ¸(2025/2026)ì— ê°™ì€ ê²€ìƒ‰ì–´ê°€ í¬í•¨ëœ ê¸°ë¡ì´ ${count}ê±´ ìˆì–´ìš”.`;

      const items = dupMatchesForTable_.slice(0, 12);
      const more = count - items.length;

      $("dupBannerDetail").innerHTML =
        items.map(m => {
          const line1 = [
            m.sheetTag ? `ì‹œíŠ¸: ${m.sheetTag}` : "",
            m.mallNo ? `ì£¼ë¬¸ë²ˆí˜¸: ${m.mallNo}` : "",
            m.reqDate ? `ìš”ì²­ì¼: ${m.reqDate}` : "",
            m.colorNm ? `ìƒí’ˆì»¬ëŸ¬ëª…: ${m.colorNm}` : ""
          ].filter(Boolean).join(" Â· ");

          const line2 = [
            m.dText ? `ë©”ëª¨: ${m.dText}` : "",
            m.eText ? `ì²˜ë¦¬: ${m.eText}` : ""
          ].filter(Boolean).join(" Â· ");

          return `
            <div class="dupCard">
              <div class="dupLine1">${escapeHtml(line1 || "ê¸°ë¡ ìƒì„¸")}</div>
              <div class="dupLine2">${escapeHtml(line2 || "")}</div>
            </div>
          `;
        }).join("") + (more > 0 ? `<div class="dupSub">â€¦ì™¸ ${more}ê±´ ë” ìˆìŒ</div>` : "");

      b.style.display = "flex";
      showToast(`ğŸ”´ ì´ì¤‘ì¶œê³  ì˜ì‹¬ ${count}ê±´`);
    }
    $("dupBannerToggle")?.addEventListener("click", ()=>{
      const d = $("dupBannerDetail");
      if(!d) return;
      const open = d.style.display !== "none";
      d.style.display = open ? "none" : "flex";
      $("dupBannerToggle").textContent = open ? "ìì„¸íˆ" : "ì ‘ê¸°";
    });

    /* ===================== ë¡œì»¬ ìºì‹œ ===================== */
    const STOCK_CACHE_KEY = "SHIPMENT_STOCK_CSV_CACHE_V1";
    const STOCK_CACHE_TTL_MS = 4 * 60 * 60 * 1000;

    const ORDER_CACHE_KEY = "SHIPMENT_ORDER_CSV_CACHE_V1";
    const EXIST_CACHE_KEY_2025 = "SHIPMENT_EXIST_CSV_CACHE_2025_V1";
    const EXIST_CACHE_KEY_2026 = "SHIPMENT_EXIST_CSV_CACHE_2026_V1";
    const ORDEREXIST_CACHE_TTL_MS = 4 * 60 * 60 * 1000;

    function loadCache_(key, ttl){
      try{
        const raw = localStorage.getItem(key);
        if(!raw) return null;
        const obj = JSON.parse(raw);
        if(!obj || !obj.csv || !obj.ts) return null;
        if(Date.now() - obj.ts > ttl) return null;
        return obj.csv;
      }catch{ return null; }
    }
    function saveCache_(key, csv){
      try{ localStorage.setItem(key, JSON.stringify({ ts: Date.now(), csv })); }catch{}
    }
    function loadStockCache_(){ return loadCache_(STOCK_CACHE_KEY, STOCK_CACHE_TTL_MS); }
    function saveStockCache_(csv){ saveCache_(STOCK_CACHE_KEY, csv); }

    /* ===================== âœ… ìŠ¤íŠ¸ë¦¬ë° íŒŒì„œ (step) ===================== */
    function parseCsvStream_(csvText, {
      onHeader,
      onRow,
      onDone,
      onError
    }){
      let headerDone = false;

      Papa.parse(csvText, {
        skipEmptyLines: true,
        worker: false,         // step/abort ì•ˆì •ì„± ìœ„í•´ false
        step: (results, parser)=>{
          const row = results.data;
          if(!row || row.length === 0) return;

          if(!headerDone){
            headerDone = true;
            onHeader?.(row.map(h => normalizeKey(h)));
            return;
          }

          try{
            onRow?.(row, parser);
          }catch(e){
            try{ parser.abort(); }catch{}
            onError?.(e);
          }
        },
        complete: ()=>{
          onDone?.();
        },
        error: (err)=>{
          onError?.(err);
        }
      });
    }

    /* ===================== ì¬ê³  ë¡œë“œ ===================== */
    let stockLoaded = false;

    async function loadStockOnly(){
      setLoadingUI_(true, "ì¬ê³  ë¡œë”© ì¤‘â€¦");
      clearStockUI();
      hideExistPanel();
      hideDupBanner_();
      setPanel("manual", false);
      setPanel("change", false);
      copyBlocked_ = true;
      wireColorSelect_();

      try{
        const cached = loadStockCache_();
        if(cached){
          buildStockFromCsvText_(cached);
          stockLoaded = true;
          rebuildColorSelectOptions_();
          setLoadingUI_(false, "ì¬ê³  ë¡œë”© ì™„ë£Œ (ìºì‹œ)");
        }

        const stockCsv = await fetchCsvSmart(STOCK_CSV_BASE);
        if(!looksLikeBadCsv(stockCsv)){
          saveStockCache_(stockCsv);
          buildStockFromCsvText_(stockCsv);
          stockLoaded = true;
          rebuildColorSelectOptions_();
          setLoadingUI_(false, "ì¬ê³  ë¡œë”© ì™„ë£Œ");
        }else{
          if(!stockLoaded) setLoadingUI_(false, "ì¬ê³  ë¡œë“œ ì‹¤íŒ¨: ì‹œíŠ¸ ê³µê°œ(ë³´ê¸° ê°€ëŠ¥) í™•ì¸");
        }
      }catch(e){
        console.error(e);
        if(!stockLoaded) setLoadingUI_(false, "ì¬ê³  ë¡œë“œ ì‹¤íŒ¨: ì‹œíŠ¸ ê³µê°œ(ë³´ê¸° ê°€ëŠ¥) í™•ì¸");
      }
    }

    function buildStockFromCsvText_(csvText){
      stockMap = new Map();
      stockInfoMap = new Map();

      let header = null;
      parseCsvStream_(csvText, {
        onHeader: (h)=>{ header = h; },
        onRow: (r)=>{
          // ê¸°ì¡´ ë¡œì§ê³¼ ë™ì¼(ì—´ ìœ„ì¹˜ ê°€ì •): A=0, F=5, I=8, K=10
          const code = normColorCode(r[0]);
          if(!code) return;
          const name = normalizeKey(r[5]);
          const colorName = normalizeKey(r[8]);
          const qty = toNumber(r[10]);
          stockMap.set(code, qty);
          stockInfoMap.set(code, { qty, name, colorName });
        }
      });
    }

    /* ===================== âœ… ë°œì£¼ ë°ì´í„°(ì••ì¶• ì €ì¥ + ì¸ë±ìŠ¤) ===================== */
    let orderLoaded = false;
    let orderHeaderMap = new Map();

    // ì¸ë±ìŠ¤: key -> compactRow[]
    let orderIndexByMall = new Map();
    let orderIndexBySabang = new Map();
    let orderIndexByTracking = new Map();
    let orderIndexByPhone = new Map();
    // ìˆ˜ë ¹ì¸ contains ê²€ìƒ‰ìš©: compactRow[] (ì „ì²´ ëª©ë¡)
    let orderAllForRecipientScan = [];

    // ë°œì£¼ compactRowëŠ” "í•„ìš” ì»¬ëŸ¼ë§Œ" ê°–ëŠ” ê°ì²´
    function compactOrderRow_(rawRow){
      // EXTRA_COLS B/C/D + OUTPUT_HEADERS ì „ë¶€
      const o = {};
      o["__B"] = rawRow[1] ?? "";
      o["__C"] = rawRow[2] ?? "";
      o["__D"] = rawRow[3] ?? "";

      // OUTPUT_HEADERSëŠ” headerMap ê¸°ë°˜ìœ¼ë¡œ ê°’ ì±„ì›€
      for(const h of OUTPUT_HEADERS){
        if(h === "ë°°ì†¡ìˆ˜ë‹¨"){ o[h] = "íƒë°°"; continue; }
        if(h === "ìš´ì†¡ì¥ ë²ˆí˜¸"){ o[h] = ""; continue; }
        if(h === "ìƒí’ˆëª…"){ // ë„¤ ì›ë³¸ ì½”ë“œê°€ row[11] ìš°ì„ ì´ì—ˆìŒ
          o[h] = rawRow[11] || safeGetByHeader_(rawRow, h) || "";
          continue;
        }
        o[h] = safeGetByHeader_(rawRow, h) || "";
      }

      // ì¬ê³ /ìš”ì²­ì¼ íƒœê·¸
      o["ì¬ê³ "] = stockQtyLabel_(o["ìƒí’ˆì»¬ëŸ¬ì½”ë“œ"]);
      o["ìš”ì²­ì¼"] = attachStockToRequestDate_(o["ìš”ì²­ì¼"], o["ìƒí’ˆì»¬ëŸ¬ì½”ë“œ"]);
      return o;
    }

    function safeGetByHeader_(row, headerName){
      const idx = orderHeaderMap.get(headerName);
      if(idx == null || idx < 0) return "";
      return row[idx] ?? "";
    }

    function pushIndex_(map, key, item){
      if(!key) return;
      if(!map.has(key)) map.set(key, []);
      map.get(key).push(item);
    }

    function parseOrderCsvStream_(csvText){
      return new Promise((resolve, reject)=>{
        // ì´ˆê¸°í™”
        orderIndexByMall = new Map();
        orderIndexBySabang = new Map();
        orderIndexByTracking = new Map();
        orderIndexByPhone = new Map();
        orderAllForRecipientScan = [];
        orderHeaderMap = new Map();

        let idxMall = 2;     // fallback
        let idxSabang = 1;   // Bì—´
        let idxTracking = null;
        let idxPhone = null;
        let idxRecipient = null;

        parseCsvStream_(csvText, {
          onHeader: (header)=>{
            // headerMap ìƒì„±
            header.forEach((h, i)=>{ if(h) orderHeaderMap.set(h, i); });

            // ì‡¼í•‘ëª°ì£¼ë¬¸ë²ˆí˜¸ ì—´ ì°¾ê¸°
            const m1 = orderHeaderMap.get("ì‡¼í•‘ëª° ì£¼ë¬¸ë²ˆí˜¸(í•„ìˆ˜)");
            const m2 = orderHeaderMap.get("ì‡¼í•‘ëª° ì£¼ë¬¸ë²ˆí˜¸");
            idxMall = (m1 != null) ? m1 : (m2 != null ? m2 : 2);

            idxTracking  = orderHeaderMap.get("ìš´ì†¡ì¥ ë²ˆí˜¸");
            idxPhone     = orderHeaderMap.get("ë°›ëŠ”ë¶„ì—°ë½ì²˜");
            idxRecipient = orderHeaderMap.get("ìˆ˜ë ¹ì¸");
          },
          onRow: (rawRow)=>{
            // ë¹ˆí–‰ ë°©ì§€
            if(!rawRow || rawRow.length < 3) return;

            const compact = compactOrderRow_(rawRow);

            // ì¸ë±ìŠ¤ í‚¤ë“¤
            const mall = normalizeOrderNo(rawRow[idxMall]);
            const sabang = normalizeKey(rawRow[idxSabang]);
            const trk = (idxTracking != null) ? normLoose_(rawRow[idxTracking]) : "";
            const ph  = (idxPhone != null) ? normDigits_(rawRow[idxPhone]) : "";

            if(mall) pushIndex_(orderIndexByMall, mall, compact);
            if(sabang) pushIndex_(orderIndexBySabang, sabang, compact);
            if(trk) pushIndex_(orderIndexByTracking, trk, compact);
            if(ph) pushIndex_(orderIndexByPhone, ph, compact);

            // ìˆ˜ë ¹ì¸ containsìš© (ì „ì²´ ì €ì¥í•˜ë˜, compactë§Œ)
            if(idxRecipient != null){
              compact.__RECIP = String(rawRow[idxRecipient] ?? "");
            }else{
              compact.__RECIP = String(compact["ìˆ˜ë ¹ì¸"] ?? "");
            }
            orderAllForRecipientScan.push(compact);
          },
          onDone: ()=>{
            orderLoaded = true;
            resolve();
          },
          onError: (e)=> reject(e)
        });
      });
    }

    /* ===================== âœ… ì¶œê³  ë°ì´í„°(ì••ì¶• ì €ì¥) ===================== */
    let existLoaded = false;

    // existItem: { sheetTag, reqDate, sabang, mall, purpose, method, colorNm, dateText }
    let existRows = [];
    let existIndexBySabang = new Map();
    let existIndexByMall = new Map();

    function parseExistCsvStream_(csvText, sheetTag){
      return new Promise((resolve, reject)=>{
        let headerMap = new Map();
        let sabangIdx = null, mallIdx = null, dateIdx = null;
        let reqDateIdx = 0;
        let purposeIdx = 3;
        let methodIdx = 4;
        let colorIdx = 13;

        parseCsvStream_(csvText, {
          onHeader: (header)=>{
            header.forEach((h, i)=>{ if(h) headerMap.set(h, i); });

            sabangIdx = headerMap.get("ì‚¬ë°©ë„·ì£¼ë¬¸ë²ˆí˜¸") ?? headerMap.get("ì‚¬ë°©ë„· ì£¼ë¬¸ë²ˆí˜¸") ?? null;
            mallIdx   = headerMap.get("ì‡¼í•‘ëª° ì£¼ë¬¸ë²ˆí˜¸(í•„ìˆ˜)") ?? headerMap.get("ì‡¼í•‘ëª° ì£¼ë¬¸ë²ˆí˜¸") ?? null;
            dateIdx   = headerMap.get("ê¸°ë¡ì¼") ?? headerMap.get("ë“±ë¡ì¼") ?? headerMap.get("ì‘ì„±ì¼") ?? null;

            // ìƒ‰ìƒëª… ì»¬ëŸ¼ëª… ëŒ€ì‘
            colorIdx = headerMap.get("ìƒí’ˆì»¬ëŸ¬ëª…(í”Œë ˆì´ì— ë””)") ?? headerMap.get("ìƒí’ˆì»¬ëŸ¬ëª…") ?? 13;
          },
          onRow: (r)=>{
            const sabang = normalizeKey(sabangIdx != null ? r[sabangIdx] : "");
            const mall   = normalizeOrderNo(mallIdx != null ? r[mallIdx] : "");
            const reqDate = String(r[reqDateIdx] ?? "").trim();
            const purpose = String(r[purposeIdx] ?? "").trim();
            const method  = String(r[methodIdx] ?? "").trim();
            const colorNm = String(r[colorIdx] ?? "").trim();
            const dt = String(dateIdx != null ? (r[dateIdx] ?? "") : "").trim();

            const item = {
              sheetTag,
              reqDate,
              sabang,
              mall,
              purpose,
              method,
              colorNm,
              dateText: dt
            };
            existRows.push(item);

            if(sabang){
              if(!existIndexBySabang.has(sabang)) existIndexBySabang.set(sabang, []);
              existIndexBySabang.get(sabang).push(item);
            }
            if(mall){
              if(!existIndexByMall.has(mall)) existIndexByMall.set(mall, []);
              existIndexByMall.get(mall).push(item);
            }
          },
          onDone: ()=>{
            existLoaded = true;
            resolve();
          },
          onError: (e)=> reject(e)
        });
      });
    }

    /* ===================== âœ… í†µí•© ë¡œë” (ìºì‹œ ìš°ì„  + ë°±ê·¸ë¼ìš´ë“œ ê°±ì‹ ) ===================== */
    let orderExistLoadingPromise = null;
    let orderExistRefreshingPromise = null;

    async function refreshOrderExistInBackground_(){
      if(orderExistRefreshingPromise) return orderExistRefreshingPromise;

      orderExistRefreshingPromise = (async ()=>{
        try{
          const [orderCsv, existCsv2025, existCsv2026] = await Promise.all([
            fetchCsvSmart(ORDER_CSV_BASE),
            fetchCsvSmart(EXIST_CSV_BASE_2025),
            fetchCsvSmart(EXIST_CSV_BASE_2026),
          ]);

          if(!looksLikeBadCsv(orderCsv)){
            saveCache_(ORDER_CACHE_KEY, orderCsv);
            await parseOrderCsvStream_(orderCsv);
          }

          // ì¶œê³ ëŠ” appendì´ë¯€ë¡œ, ë°±ê·¸ë¼ìš´ë“œ ê°±ì‹ ì€ í•œ ë²ˆ ì´ˆê¸°í™” í›„ ì¬ë¹Œë“œ
          if(!looksLikeBadCsv(existCsv2025) || !looksLikeBadCsv(existCsv2026)){
            existRows = [];
            existIndexBySabang = new Map();
            existIndexByMall = new Map();
          }

          if(!looksLikeBadCsv(existCsv2025)){
            saveCache_(EXIST_CACHE_KEY_2025, existCsv2025);
            await parseExistCsvStream_(existCsv2025, "2025");
          }
          if(!looksLikeBadCsv(existCsv2026)){
            saveCache_(EXIST_CACHE_KEY_2026, existCsv2026);
            await parseExistCsvStream_(existCsv2026, "2026");
          }
        }catch(e){
          console.warn("background refresh failed", e);
        }finally{
          orderExistRefreshingPromise = null;
        }
      })();

      return orderExistRefreshingPromise;
    }

    async function ensureOrderAndExistLoaded_(){
      if(orderLoaded && existLoaded) return;
      if(orderExistLoadingPromise) return orderExistLoadingPromise;

      orderExistLoadingPromise = (async ()=>{
        setLoadingUI_(true, "ë°œì£¼/ì¶œê³  ë°ì´í„° ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘â€¦");

        try{
          // ìºì‹œ ë¨¼ì €
          const cachedOrder = loadCache_(ORDER_CACHE_KEY, ORDEREXIST_CACHE_TTL_MS);
          const cachedExist2025 = loadCache_(EXIST_CACHE_KEY_2025, ORDEREXIST_CACHE_TTL_MS);
          const cachedExist2026 = loadCache_(EXIST_CACHE_KEY_2026, ORDEREXIST_CACHE_TTL_MS);

          if(cachedOrder && !orderLoaded) await parseOrderCsvStream_(cachedOrder);

          if((cachedExist2025 || cachedExist2026) && !existLoaded){
            existRows = [];
            existIndexBySabang = new Map();
            existIndexByMall = new Map();
          }

          if(cachedExist2025 && !existLoaded) await parseExistCsvStream_(cachedExist2025, "2025");
          if(cachedExist2026) await parseExistCsvStream_(cachedExist2026, "2026");

          if(orderLoaded && existLoaded){
            setLoadingUI_(false, "ë¡œë”© ì™„ë£Œ (ìºì‹œ)");
            orderExistLoadingPromise = null;
            refreshOrderExistInBackground_();
            return;
          }

          // ë„¤íŠ¸ì›Œí¬
          const [orderCsv, existCsv2025, existCsv2026] = await Promise.all([
            fetchCsvSmart(ORDER_CSV_BASE),
            fetchCsvSmart(EXIST_CSV_BASE_2025),
            fetchCsvSmart(EXIST_CSV_BASE_2026),
          ]);

          if(!looksLikeBadCsv(orderCsv)){
            saveCache_(ORDER_CACHE_KEY, orderCsv);
            await parseOrderCsvStream_(orderCsv);
          }

          existRows = [];
          existIndexBySabang = new Map();
          existIndexByMall = new Map();

          if(!looksLikeBadCsv(existCsv2025)){
            saveCache_(EXIST_CACHE_KEY_2025, existCsv2025);
            await parseExistCsvStream_(existCsv2025, "2025");
          }
          if(!looksLikeBadCsv(existCsv2026)){
            saveCache_(EXIST_CACHE_KEY_2026, existCsv2026);
            await parseExistCsvStream_(existCsv2026, "2026");
          }

          setLoadingUI_(false, "ë¡œë”© ì™„ë£Œ");
        }catch(e){
          console.error(e);
          setLoadingUI_(false, "ë¡œë“œ ì‹¤íŒ¨: ì‹œíŠ¸ê°€ 'ë³´ê¸° ê°€ëŠ¥' ê³µê°œì¸ì§€ í™•ì¸í•˜ì„¸ìš”.");
          throw e;
        }finally{
          orderExistLoadingPromise = null;
        }
      })();

      return orderExistLoadingPromise;
    }

    /* ===================== ê¸°ì¡´ ë“±ë¡ íŒ¨ë„ ===================== */
    function hideExistPanel(){
      const p = $("existPanel");
      if (!p) return;
      p.style.display = "none";
      $("existBody").style.display = "none";
      $("btnExistToggle").textContent = "í¼ì¹˜ê¸°";
      $("existTbody").innerHTML = "";
    }

    function showExistPanelByOrderNo_(orderNo){
      const keyMall = normalizeOrderNo(orderNo);
      const rowsByMall = existIndexByMall.get(keyMall) || [];

      const sabangKeys = [];
      if(lastSource === "sheet" && lastOutRows && lastOutRows.length){
        for(const o of lastOutRows){
          const v = normalizeKey(o["__B"]);
          if(v) sabangKeys.push(v);
        }
      }
      const rowsBySabang = sabangKeys.flatMap(k => existIndexBySabang.get(k) || []);

      const merged = [...rowsByMall, ...rowsBySabang];

      const uniq = [];
      const seen = new Set();
      for(const it of merged){
        const sig = (it.sheetTag || "") + "::" + (it.mall || "") + "::" + (it.sabang || "") + "::" + (it.purpose||"") + "::" + (it.method||"") + "::" + (it.reqDate||"");
        if(seen.has(sig)) continue;
        seen.add(sig);
        uniq.push(it);
      }

      if(uniq.length === 0){
        hideExistPanel();
        return;
      }

      const panel = $("existPanel");
      panel.style.display = "flex";
      $("existBody").style.display = "none";
      $("btnExistToggle").textContent = `í¼ì¹˜ê¸° (${uniq.length}ê±´)`;

      $("existTbody").innerHTML = uniq.map(it=>{
        const sheetTag = it.sheetTag ? ` (${it.sheetTag})` : "";
        return `
          <tr>
            <td>${escapeHtml(it.sabang || "")}</td>
            <td>${escapeHtml(it.mall || "")}</td>
            <td>${escapeHtml(it.purpose || "")}</td>
            <td>${escapeHtml(it.method || "")}</td>
            <td>${escapeHtml(it.dateText || it.reqDate || "")}${escapeHtml(sheetTag)}</td>
          </tr>
        `;
      }).join("");
    }

    /* ===================== DUP ë§¤ì¹­(ì¶œê³  ìŠ¤ìº”) ===================== */
    function computeDupMatchesForTable_(needleRaw){
      dupMatchesForTable_ = [];
      const q0 = normalizeForContains_(needleRaw);
      if(!q0) return;
      if(!existLoaded || !existRows || existRows.length === 0) return;

      for(const it of existRows){
        const dNorm = normalizeForContains_(it.purpose || "");
        const eNorm = normalizeForContains_(it.method || "");
        if(dNorm.includes(q0) || eNorm.includes(q0)){
          dupMatchesForTable_.push({
            reqDate: it.reqDate || "",
            mallNo: it.mall || "",
            colorNm: it.colorNm || "",
            dText: it.purpose || "",
            eText: it.method || "",
            sheetTag: it.sheetTag || ""
          });
        }
      }
    }

    /* ===================== ê²°ê³¼/ë³µì‚¬/ë Œë” ===================== */
    let lastOutRows = [];
    let lastStockTypes = [];
    let originalOutRows = [];
    let lastSource = "none";
    let copyBlocked_ = true;

    function clearResult_(){
      setPanel("manual", false);
      setPanel("change", false);
      clearStockUI();
      hideExistPanel();
      hideDupBanner_();
      lastOutRows = [];
      lastStockTypes = [];
      originalOutRows = [];
      lastSource = "none";
      copyBlocked_ = true;
    }

    function getCheckedIndexes_(){
      const wrap = $("tableWrap");
      const chks = wrap.querySelectorAll("input.rowChk:checked");
      return Array.from(chks).map(c => Number(c.dataset.idx)).filter(n => !Number.isNaN(n));
    }

    function updateToolbar_(){
      const tb = $("tableToolbar");
      if(!tb) return;
      const hasRows = lastOutRows && lastOutRows.length > 0;
      tb.style.display = hasRows ? "flex" : "none";
      const showBulk = hasRows && lastOutRows.length > 1;
      $("btnSelectAll").style.display = showBulk ? "" : "none";
      $("btnSelectNone").style.display = showBulk ? "" : "none";

      const checked = getCheckedIndexes_().length;
      const selBadge = $("selCount");
      if(selBadge){
        selBadge.style.display = showBulk ? "" : "none";
        selBadge.textContent = `ì„ íƒ ${checked}ê±´`;
        selBadge.className = checked ? "badge ok" : "badge na";
      }
    }

    $("btnSelectAll")?.addEventListener("click", ()=>{
      const wrap = $("tableWrap");
      wrap.querySelectorAll("input.rowChk").forEach(c => c.checked = true);
      wrap.querySelectorAll("tbody tr").forEach(tr => tr.classList.add("is-selected"));
      refreshColorDropdownByCurrentRows_();
      updateToolbar_();
      updateCopyGateBySelection_();
    });

    $("btnSelectNone")?.addEventListener("click", ()=>{
      const wrap = $("tableWrap");
      wrap.querySelectorAll("input.rowChk").forEach(c => c.checked = false);
      wrap.querySelectorAll("tbody tr").forEach(tr => tr.classList.remove("is-selected"));
      refreshColorDropdownByCurrentRows_();
      updateToolbar_();
      updateCopyGateBySelection_();
    });

    // hover tip
    let hoverTipEl = null;
    let hoverTipActive = false;
    function initHoverTip_(){ hoverTipEl = $("hoverTip"); }
    function showHoverTip_(text, clientX, clientY){
      if(!hoverTipEl) return;
      const t = String(text ?? "").trim();
      if(!t) return;
      hoverTipEl.textContent = t;
      hoverTipEl.classList.add("show");
      hoverTipActive = true;
      moveHoverTip_(clientX, clientY);
    }
    function moveHoverTip_(clientX, clientY){
      if(!hoverTipEl || !hoverTipActive) return;
      const pad = 14, offset = 14;
      hoverTipEl.style.left = "0px"; hoverTipEl.style.top = "0px";
      const rect = hoverTipEl.getBoundingClientRect();
      let x = clientX + offset;
      let y = clientY + offset;
      const vw = window.innerWidth, vh = window.innerHeight;
      if(x + rect.width + pad > vw) x = Math.max(pad, vw - rect.width - pad);
      if(y + rect.height + pad > vh) y = Math.max(pad, clientY - rect.height - offset);
      hoverTipEl.style.left = `${x}px`;
      hoverTipEl.style.top = `${y}px`;
    }
    function hideHoverTip_(){
      if(!hoverTipEl) return;
      hoverTipEl.classList.remove("show");
      hoverTipActive = false;
    }

    function renderTable(outRows, stockTypes){
      const wrap = $("tableWrap");
      lastOutRows = outRows || [];
      lastStockTypes = stockTypes || [];
      clearStockUI();

      if(!outRows || outRows.length === 0){
        wrap.innerHTML = `<div class="no-data">ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.</div>`;
        updateToolbar_();
        hideHoverTip_();
        copyBlocked_ = true;
        return;
      }

      let html = `
        <table>
          <thead>
            <tr>
              <th style="min-width:20px;">#</th>
              <th style="min-width:30px;">ì„ íƒ</th>
              ${TABLE_COLS_VIEW.map(c=>{
                const w = COL_WIDTH[c.label] || COL_WIDTH["_default"];
                return `<th style="min-width:${w}px; max-width:${w}px;">${escapeHtml(c.label)}</th>`;
              }).join("")}
            </tr>
          </thead>
          <tbody>
      `;

      outRows.forEach((o, i)=>{
        const t = stockTypes[i] || "na";
        const trClass = t === "low" ? "low" : t === "out" ? "out" : t === "na" ? "na" : "";
        html += `
          <tr class="${trClass}" data-idx="${i}">
            <td class="copy" data-copy="${i+1}">${i+1}</td>
            <td class="chkcell"><input type="checkbox" class="rowChk" data-idx="${i}"></td>
            ${TABLE_COLS_VIEW.map(c=>{
              const v = o[c.key] ?? "";
              const w = COL_WIDTH[c.label] || COL_WIDTH["_default"];
              const raw = String(v ?? "");
              return `
                <td class="copy"
                    style="min-width:${w}px; max-width:${w}px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"
                    data-copy="${escapeHtml(raw)}">
                  ${escapeHtml(raw)}
                </td>
              `;
            }).join("")}
          </tr>
        `;
      });

      html += `</tbody></table>`;
      wrap.innerHTML = html;

      refreshColorDropdownByCurrentRows_();

      wrap.querySelectorAll("input.rowChk").forEach(chk=>{
        chk.addEventListener("change", ()=>{
          const tr = chk.closest("tr");
          if(tr) tr.classList.toggle("is-selected", chk.checked);
          refreshColorDropdownByCurrentRows_();
          updateToolbar_();
          updateCopyGateBySelection_();
        });
      });

      updateToolbar_();
      updateCopyGateBySelection_();

      wrap.querySelectorAll(".copy").forEach(td=>{
        td.addEventListener("click", async ()=>{
          const text = (td.getAttribute("data-copy") || td.textContent || "").trim();
          try{
            await navigator.clipboard.writeText(text);
            showToast("ë³µì‚¬ë¨");
          }catch{
            showToast("ë³µì‚¬ ì‹¤íŒ¨");
          }
        });

        td.addEventListener("mouseenter", (e)=>{
          const text = (td.getAttribute("data-copy") || td.textContent || "").trim();
          const t = text.length > 4000 ? (text.slice(0, 4000) + " â€¦") : text;
          showHoverTip_(t, e.clientX, e.clientY);
        });
        td.addEventListener("mousemove", (e)=> moveHoverTip_(e.clientX, e.clientY));
        td.addEventListener("mouseleave", hideHoverTip_);
      });
    }

    function buildTSV(outRows){
      const lines = [];
      outRows.forEach(o=>{
        const vals = TABLE_COLS_COPY.map(c =>
          String(o[c.key] ?? "").replace(/\t/g," ").replace(/\r?\n/g," ")
        );
        lines.push(vals.join("\t"));
      });
      return lines.join("\n");
    }

    function buildHTMLTable(outRows){
      const tdStyle = "border:1px solid #eee;padding:6px 8px;text-align:center;vertical-align:middle;";
      const tbody = outRows.map(o => {
        const tds = TABLE_COLS_COPY.map(c =>
          `<td style="${tdStyle}">${escapeHtml(String(o[c.key] ?? ""))}</td>`
        ).join("");
        return `<tr>${tds}</tr>`;
      }).join("");
      return `<table style="border-collapse:collapse;"><tbody>${tbody}</tbody></table>`.trim();
    }

    async function writeClipboardRows_(rowsToCopy){
      const tsv = buildTSV(rowsToCopy);
      const html = buildHTMLTable(rowsToCopy);
      try{
        await navigator.clipboard.write([
          new ClipboardItem({
            "text/plain": new Blob([tsv], { type: "text/plain" }),
            "text/html": new Blob([html], { type: "text/html" }),
          })
        ]);
        showToast(`í†µì§¸ë¡œ ë³µì‚¬ë¨ (${rowsToCopy.length}ê±´)`);
      }catch(e){
        try{
          await navigator.clipboard.writeText(tsv);
          showToast(`ë³µì‚¬ë¨ (${rowsToCopy.length}ê±´, ì„œì‹ ì œì™¸)`);
        }catch{
          showToast("ë³µì‚¬ ì‹¤íŒ¨");
        }
      }
    }

    function getSelectedRowIndexesByDrag_(){
      const wrap = $("tableWrap");
      const sel = window.getSelection?.();
      if(!wrap || !sel || sel.rangeCount === 0) return [];
      const anchorNode = sel.anchorNode;
      const focusNode = sel.focusNode;
      const inWrap = (n)=> n && (wrap === n || wrap.contains(n));
      if(!inWrap(anchorNode) && !inWrap(focusNode)) return [];
      const range = sel.getRangeAt(0);
      const rows = Array.from(wrap.querySelectorAll("tbody tr[data-idx]"));
      const idxs = [];
      for(const tr of rows){
        try{
          if(range.intersectsNode(tr)){
            const i = Number(tr.dataset.idx);
            if(!Number.isNaN(i)) idxs.push(i);
          }
        }catch{}
      }
      return Array.from(new Set(idxs)).sort((a,b)=>a-b);
    }

    function isTypingTarget_(el){
      if(!el) return false;
      const tag = (el.tagName || "").toLowerCase();
      if(tag === "input" && (el.type || "").toLowerCase() === "checkbox") return false;
      if(tag === "input" || tag === "textarea" || tag === "select") return true;
      if(el.isContentEditable) return true;
      return false;
    }

    function getCopyTargetIndexes_(){
      if(!lastOutRows || lastOutRows.length === 0) return [];
      const checked = getCheckedIndexes_();
      return (checked && checked.length) ? checked : lastOutRows.map((_, i)=>i);
    }

    function gateCopyByTypes(types){
      let out=0, low=0, na=0, ok=0;
      for(const t of types){
        if(t === "out") out++;
        else if(t === "low") low++;
        else if(t === "na") na++;
        else ok++;
      }
      copyBlocked_ = (out > 0 || low > 0 || na > 0);
    }

    function updateCopyGateBySelection_(){
      if(!lastOutRows || lastOutRows.length === 0){
        copyBlocked_ = true;
        return;
      }
      const idxs = getCopyTargetIndexes_();
      const types = idxs.map(i => stockStatusByColorCode(lastOutRows[i]["ìƒí’ˆì»¬ëŸ¬ì½”ë“œ"]).type);
      gateCopyByTypes(types);
    }

    async function shortcutCopy_(){
      if(!lastOutRows || lastOutRows.length === 0){
        showToast("ë³µì‚¬í•  ê²°ê³¼ ì—†ìŒ");
        return;
      }
      updateCopyGateBySelection_();
      if(copyBlocked_){
        showToast("ì¬ê³  ê²½ê³ ë¡œ ë³µì‚¬ ì°¨ë‹¨ë¨");
        return;
      }

      let idxs = getCheckedIndexes_();
      if(!idxs.length){
        const dragIdxs = getSelectedRowIndexesByDrag_();
        if(dragIdxs.length) idxs = dragIdxs;
      }
      if(!idxs.length){
        idxs = lastOutRows.map((_, i)=>i);
      }

      const rowsToCopy = idxs.map(i => lastOutRows[i]).filter(Boolean);
      await writeClipboardRows_(rowsToCopy);
    }

    /* ===================== ìˆ˜ë™ ì…ë ¥ ===================== */
    function buildOutManual(colorCode, qty){
      const o = {};
      for(const c of EXTRA_COLS) o[c.key] = "";
      for(const h of OUTPUT_HEADERS) o[h] = "";
      o["ë°°ì†¡ìˆ˜ë‹¨"] = "íƒë°°";
      o["ìš´ì†¡ì¥ ë²ˆí˜¸"] = "";
      o["ìƒí’ˆì»¬ëŸ¬ì½”ë“œ"] = colorCode || "";
      o["ìˆ˜ëŸ‰"] = qty || "";
      o["ìƒí’ˆëª…"] = nameFromStock_(o["ìƒí’ˆì»¬ëŸ¬ì½”ë“œ"]);
      o["ì¬ê³ "] = stockQtyLabel_(o["ìƒí’ˆì»¬ëŸ¬ì½”ë“œ"]);
      o["ì˜µì…˜(ìˆ˜ì§‘)"] = colorNameFromStock_(o["ìƒí’ˆì»¬ëŸ¬ì½”ë“œ"]);
      return o;
    }

    function applyManual(){
      const color = normalizeKey($("manualColor").value);
      const qty = normalizeKey($("manualQty").value);

      if(!color){ showToast(""); return; }
      if(!stockLoaded){ showToast("ì¬ê³  ë¡œë”© ì¤‘â€¦"); return; }

      const out = buildOutManual(color, qty);
      const st = stockStatusByColorCode(out["ìƒí’ˆì»¬ëŸ¬ì½”ë“œ"]);
      lastSource = "manual";
      originalOutRows = JSON.parse(JSON.stringify([out]));
      $("status").textContent = "ìˆ˜ë™ ì…ë ¥ ê²°ê³¼: 1ê±´";
      renderTable([out], [st.type]);
    }

    /* ===================== ìƒí’ˆ ë³€ê²½ ===================== */
    function applyChange(){
      if(lastSource !== "sheet" || !lastOutRows || lastOutRows.length === 0){
        showToast("ë³€ê²½í•  ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤");
        return;
      }
      const newColor = normalizeKey($("changeColor").value);
      const newQty = normalizeKey($("changeQty").value);

      if(!newColor){
        showToast("ë³€ê²½ ì»¬ëŸ¬ì½”ë“œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”");
        return;
      }

      let targets = [];
      if(lastOutRows.length > 1){
        targets = getCheckedIndexes_();
        if(targets.length === 0){
          showToast("í–‰ì„ ì²´í¬í•´ì£¼ì„¸ìš”");
          return;
        }
      }else{
        targets = [0];
      }

      const targetSet = new Set(targets);
      const updated = lastOutRows.map((o, idx)=>{
        const copy = { ...o };
        if(targetSet.has(idx)){
          copy["ìƒí’ˆì»¬ëŸ¬ì½”ë“œ"] = newColor;
          if(newQty !== "") copy["ìˆ˜ëŸ‰"] = newQty;
          copy["ìƒí’ˆëª…"] = nameFromStock_(newColor);
          copy["ìš”ì²­ì¼"] = attachStockToRequestDate_(copy["ìš”ì²­ì¼"], newColor);
          copy["ì˜µì…˜(ìˆ˜ì§‘)"] = colorNameFromStock_(newColor);
        }
        return copy;
      });

      const types = updated.map(o => stockStatusByColorCode(o["ìƒí’ˆì»¬ëŸ¬ì½”ë“œ"]).type);
      renderTable(updated, types);
      showToast(`ì„ íƒ ${targets.length}ê±´ì—ë§Œ ì ìš©ë¨`);
    }

    function resetChange(){
      if(!originalOutRows || originalOutRows.length === 0){
        showToast("ë˜ëŒë¦´ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤");
        return;
      }
      const restored = JSON.parse(JSON.stringify(originalOutRows));
      const types = restored.map(o => stockStatusByColorCode(o["ìƒí’ˆì»¬ëŸ¬ì½”ë“œ"]).type);
      renderTable(restored, types);
      showToast("ë³€ê²½ ì·¨ì†Œë¨");
    }

    /* ===================== âœ… ê²€ìƒ‰ ===================== */
    async function search(){
      const inputRaw = $("orderInput").value;
      const qKey = normalizeKey(inputRaw);
      const qMall = normalizeOrderNo(inputRaw);
      const qLoose = normLoose_(inputRaw);
      const qDigits = normDigits_(inputRaw);

      clearResult_();

      if(!qKey){
        $("tableWrap").innerHTML = `<div class="no-data">ê²€ìƒ‰ì–´ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.</div>`;
        updateToolbar_();
        hideHoverTip_();
        return;
      }
      if(!stockLoaded){
        $("status").textContent = "ì¬ê³  ë¡œë”© ì¤‘â€¦";
        return;
      }

      if(!orderLoaded || !existLoaded){
        try{
          await ensureOrderAndExistLoaded_();
        }catch{
          $("status").textContent = "ë°œì£¼/ì¶œê³  ë¡œë“œ ì‹¤íŒ¨ (ìˆ˜ë™ ì…ë ¥ ê°€ëŠ¥)";
          setPanel("manual", true);
          $("tableWrap").innerHTML =
            `<div class="no-data">ë°œì£¼ì„œ/ì¶œê³  ì‹œíŠ¸ë¥¼ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.<br/>ì•„ë˜ì—ì„œ <strong>ìƒí’ˆì»¬ëŸ¬ì½”ë“œ</strong>ë¥¼ ì…ë ¥í•˜ë©´ ì¬ê³  í™•ì¸ í›„ ê²°ê³¼ í…Œì´ë¸”ì„ ë§Œë“¤ ìˆ˜ ìˆì–´ìš”.</div>`;
          updateToolbar_();
          hideHoverTip_();
          return;
        }
      }

      // âœ… (1) ë°œì£¼ ê²°ê³¼ ë¨¼ì €: ì¸ë±ìŠ¤ë¡œ ì¦‰ì‹œ ê²€ìƒ‰
      let picked = [];
      picked = picked.concat(orderIndexByMall.get(qMall) || []);
      picked = picked.concat(orderIndexBySabang.get(qKey) || []);
      picked = picked.concat(orderIndexByTracking.get(qLoose) || []);
      if(qDigits) picked = picked.concat(orderIndexByPhone.get(qDigits) || []);

      // ìˆ˜ë ¹ì¸ contains (ì „ì²´ scanì´ì§€ë§Œ compactë¼ì„œ ì´ì „ë³´ë‹¤ ëœ ë¬´ê±°ì›€)
      if(qKey.length >= 1){
        const hit = orderAllForRecipientScan.filter(o => String(o.__RECIP || "").includes(qKey));
        picked = picked.concat(hit);
      }

      // ì¤‘ë³µ ì œê±°
      const seen = new Set();
      const outRows = [];
      for(const o of picked){
        // compact rowëŠ” JSON stringifyê°€ ë¶€ë‹´ì´ë¼, ì•ˆì •ì  ì‹œê·¸ë‹ˆì²˜ë¡œ:
        const sig = (o["__B"]||"") + "|" + (o["__C"]||"") + "|" + (o["ìƒí’ˆì»¬ëŸ¬ì½”ë“œ"]||"") + "|" + (o["ìš”ì²­ì¼"]||"") + "|" + (o["ìˆ˜ëŸ‰"]||"");
        if(seen.has(sig)) continue;
        seen.add(sig);
        outRows.push(o);
      }

      $("status").textContent = outRows.length ? `ê²€ìƒ‰ ê²°ê³¼: ${outRows.length.toLocaleString()}ê±´` : "ê²€ìƒ‰ ê²°ê³¼ ì—†ìŒ (ìˆ˜ë™ ì…ë ¥ ê°€ëŠ¥)";

      if(outRows.length === 0){
        setPanel("manual", true);
        $("tableWrap").innerHTML =
          `<div class="no-data">ë°œì£¼ì„œì—ì„œ ì¼ì¹˜ í•­ëª©ì„ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.<br/>ì•„ë˜ì—ì„œ <strong>ìƒí’ˆì»¬ëŸ¬ì½”ë“œ</strong>ë¥¼ ì…ë ¥í•˜ë©´ ì¬ê³  í™•ì¸ í›„ ê²°ê³¼ í…Œì´ë¸”ì„ ë§Œë“¤ ìˆ˜ ìˆì–´ìš”.</div>`;
        updateToolbar_();
        hideHoverTip_();
        return;
      }

      const stockTypes = outRows.map(o => stockStatusByColorCode(o["ìƒí’ˆì»¬ëŸ¬ì½”ë“œ"]).type);
      lastSource = "sheet";
      originalOutRows = JSON.parse(JSON.stringify(outRows));
      renderTable(outRows, stockTypes);

      setPanel("change", true);
      $("changeColor").value = normalizeKey(outRows[0]["ìƒí’ˆì»¬ëŸ¬ì½”ë“œ"] || "");
      $("changeQty").value = normalizeKey(outRows[0]["ìˆ˜ëŸ‰"] || "");
      refreshColorDropdownByCurrentRows_();

      // âœ… (2) ì¶œê³  ê²€í† ëŠ” ë’¤ë¡œ ë¯¸ë¤„ì„œ ì²´ê° ì†ë„ ê°œì„ 
      setTimeout(()=>{
        try{
          computeDupMatchesForTable_(inputRaw);
          renderDupBanner_();
        }catch(e){ console.warn(e); }

        try{
          // ê¸°ì¡´ë“±ë¡ íŒ¨ë„ì€ ì‡¼í•‘ëª°ì£¼ë¬¸ë²ˆí˜¸ ê¸°ë°˜ì´ ì œì¼ ì •í™•
          showExistPanelByOrderNo_(qMall);
        }catch(e){ console.warn(e); }
      }, 0);
    }

    /* ===================== EXIST í† ê¸€ ===================== */
    $("btnExistToggle").addEventListener("click", ()=>{
      const body = $("existBody");
      const isOpen = body.style.display !== "none";
      body.style.display = isOpen ? "none" : "block";
      $("btnExistToggle").textContent = isOpen ? "í¼ì¹˜ê¸°" : "ì ‘ê¸°";
    });

    /* ===================== Ctrl+C ===================== */
    document.addEventListener("keydown", async (e)=>{
      const key = (e.key || "").toLowerCase();
      if(!e.ctrlKey || e.altKey || e.metaKey) return;
      if(key !== "c") return;
      if(isTypingTarget_(e.target)) return;

      if(lastOutRows && lastOutRows.length > 0){
        e.preventDefault();
        await shortcutCopy_();
      }
    });

    /* ===================== ì´ˆê¸°í™” ===================== */
    function resetAll_(){
      $("orderInput").value = "";
      $("manualColor").value = "";
      $("manualQty").value = "";
      $("changeColor").value = "";
      $("changeQty").value = "";
      const sel = $("changeColorSelect");
      if(sel) sel.value = "";

      $("status").textContent = "ì´ˆê¸°í™”ë¨";
      $("tableWrap").innerHTML = `<div class="no-data">ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.</div>`;
      clearStockUI();
      hideExistPanel();
      hideDupBanner_();
      setPanel("manual", false);
      setPanel("change", false);

      lastOutRows = [];
      lastStockTypes = [];
      originalOutRows = [];
      lastSource = "none";
      copyBlocked_ = true;

      updateToolbar_();
      hideHoverTip_();
    }

    /* ===================== ì´ë²¤íŠ¸ ===================== */
    $("orderInput").addEventListener("keydown", (e)=>{
      if(e.key === "Enter") search();
    });
    $("btnManualApply").addEventListener("click", applyManual);
    $("btnChangeApply").addEventListener("click", applyChange);
    $("btnChangeReset").addEventListener("click", resetChange);

    /* ===================== ì‹œì‘ ===================== */
    initHoverTip_();
    loadStockOnly();
  </script>
</body>
</html>
